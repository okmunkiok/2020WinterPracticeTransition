## 🚀 프로젝트 목록 (Projects)

### 1. 📡 UWB를 이용한 실내 측위 시스템 (Indoor Positioning System using UWB)
*   **한 줄 요약**: UWB(초광대역) 통신과 삼변측량법을 이용해 GPS 음영 지역인 실내에서 정밀한 2차원 위치를 추적하는 시스템입니다.
*   **주요 기술**: `ESP32`, `UWB (DWM1000)`, `C++`, `DS-TWR`, `삼변측량`

<br>

### 2. ⚙️ BLDC 모터 제어 (BLDC Motor Control)
*   **한 줄 요약**: 두 개의 ESP32를 Master-Slave 구조로 구성하여 홀 센서 피드백 기반의 BLDC 모터 속도/위치 폐쇄 루프 제어 시스템을 구현하였습니다.
*   **주요 기술**: `ESP32`, `BLDC 모터`, `홀 센서`, `C++`, `FreeRTOS`, `UART`

<br>

### 3. 🦾 로봇 팔 제어 (Robotic Arm Control)
*   **한 줄 요약**: 다수의 ESP32를 WiFi-Mesh 네트워크로 연결하여, 중앙 제어기에서 여러 관절을 무선으로 동시에 제어하는 분산 제어 시스템입니다.
*   **주요 기술**: `ESP32`, `스테퍼 모터`, `C++`, `WiFi-Mesh`, `JSON`

<br>
<br>
<br>

# 1. 📡 UWB를 이용한 실내 측위 시스템 (Indoor Positioning System using UWB)

*   아주대학교 전자공학과 20-동계방학 인턴 근무 시절 진행한 임베디드 시스템 프로젝트입니다.
*   UWB(초광대역) 통신 기술을 사용하여 GPS 음영 지역인 실내에서 이동하는 태그(Tag)의 2차원 위치를 정밀하게 추적하는 시스템을 개발하였습니다.

---

<br>

<details>
<summary><strong>👨‍💼 비전공자를 위한 프로젝트 설명 (클릭하여 펼치기)</strong></summary>

### 1. 프로젝트 소개
*   **목표**: GPS가 작동하지 않는 실내 환경에서, UWB(초광대역) 통신 기술을 이용해 특정 사물(Tag)의 위치를 센티미터(cm) 단위로 정밀하게 찾아내는 시스템을 개발하였습니다.
*   **의의**: 이 프로젝트를 통해 **임베디드 시스템 개발 역량**과 **통신 및 수학적 알고리즘에 대한 이해도**를 보여드리고자 하였습니다.  정밀 추적 및 제어 기술의 기본 원리를 이해하고 구현할 수 있는 잠재력을 가지고 있습니다.

### 2. 주요 기능
*   **정밀 거리 측정**: 실내 공간에 고정된 3개의 기준점(Anchor)과 움직이는 사물(Tag) 간의 거리를 UWB 통신을 통해 측정합니다.
*   **위치 좌표 계산**: 측정된 3개의 거리 값을 바탕으로 '삼변측량법'이라는 수학 원리를 이용해, 사물(Tag)의 현재 2차원(x, y) 좌표를 실시간으로 계산합니다.
*   **결과 시각화**: 각 기준점과의 거리, 그리고 최종 계산된 위치 좌표를 작은 OLED 화면에 실시간으로 출력하여 사용자가 직관적으로 현황을 파악할 수 있도록 구현하였습니다.

### 3. 프로젝트를 통해 얻은 역량
*   **하드웨어와 소프트웨어 통합 능력**: ESP32 마이크로컨트롤러와 DWM1000 UWB 통신 모듈이라는 하드웨어를 직접 제어하는 펌웨어(소프트웨어)를 개발하며, 하드웨어와 소프트웨어를 아우르는 임베디드 시스템 개발의 기본기를 다졌습니다.
*   **통신 프로토콜에 대한 이해**: 두 장비가 서로 시간 정보를 정밀하게 주고받아 거리를 계산하는 TWR(Two-Way Ranging) 통신 방식을 직접 코드로 구현하며, 안정적인 데이터 통신 원리를 체득하였습니다.
*   **문제 해결 능력**: '실내 위치 추적'이라는 구체적인 문제를 해결하기 위해, 삼변측량법이라는 수학적 알고리즘을 C++ 코드로 구현하고 실제 환경에서 발생하는 오차를 다루는 과정을 통해 이론을 현실에 적용하는 능력을 길렀습니다.

</details>

<br>

<details>
<summary><strong>👩‍💻 전공자를 위한 프로젝트 설명 (클릭하여 펼치기)</strong></summary>

### 1. 프로젝트 개요
본 프로젝트는 ESP32-WROOM-32 MCU와 Decawave DWM1000 UWB 모듈을 사용하여 2D 실내 측위 시스템(IPS)을 구현한 것입니다. 3개의 Anchor 노드와 1개의 Tag 노드로 구성되며, Tag는 각 Anchor와의 거리를 순차적으로 측정한 뒤 최소제곱법 기반의 삼변측량 알고리즘을 통해 자신의 (x, y) 좌표를 계산합니다.

### 2. 사용 기술
*   **MCU**: `ESP32-WROOM-32`
*   **UWB Module**: `Decawave DWM1000`
*   **Language/Framework**: `C++`, `Arduino Framework`
*   **Display**: `SSD1306 OLED Display`
*   **Libraries**: `arduino-dw1000`, `Adafruit_GFX`, `Adafruit_SSD1306`
*   **Core Algorithms**: Double-Sided Two-Way Ranging (DS-TWR), Least-Squares Trilateration

### 3. 시스템 아키텍처 및 처리 흐름
시스템은 1개의 Tag와 3개의 Anchor로 구성되며, 전체 동작은 Tag가 주도합니다.

1.  **하드웨어 구성**
    *   Tag와 Anchor 모두 ESP32와 DWM1000 모듈로 구성됩니다. 코드를 통해 SPI 통신을 위해 `RST(15)`, `IRQ(17)`, `SS(2)` 핀을 사용함을 확인할 수 있습니다.
    *   Tag에는 거리 및 좌표 정보 시각화를 위해 I2C 인터페이스 기반의 SSD1306 OLED 디스플레이가 추가됩니다.

2.  **거리 측정: DS-TWR (Double-Sided Two-Way Ranging) 프로토콜**
    클럭 오프셋으로 인한 오차를 최소화하기 위해 코드 내 `computeRangeAsymmetric()` 함수로 구현된 DS-TWR 방식을 채택하였습니다.
    *   Tag가 특정 Anchor에게 `POLL` 메시지를 보내면, Anchor는 `POLL_ACK`로 응답합니다.
    *   이후 Tag와 Anchor는 `RANGE`와 `RANGE_REPORT` 메시지를 순차적으로 교환하며, 양측에서 측정한 타임스탬프 정보들을 공유합니다.
    *   최종적으로 Tag는 6개의 타임스탬프 정보를 DS-TWR 공식에 대입하여 두 디바이스 간의 정밀한 비행시간(ToF)을 계산하고, 이를 거리로 변환합니다.

3.  **위치 계산: 최소제곱법 기반 삼변측량 (Least-Squares Trilateration)**
    *   Tag는 0번부터 2번 Anchor까지 순차적으로 거리 측정을 반복하여 `distance[0]`, `distance[1]`, `distance[2]` 값을 얻습니다.
    *   `get_position()` 함수에서 사전 정의된 Anchor들의 좌표와 측정된 거리 값들을 이용하여 위치 계산을 수행합니다. 측정값이 3개일 때의 과결정 시스템(overdetermined system)을 풀기 위해 `X = (A^T * A)^-1 * A^T * B` 공식을 C++ 코드로 직접 구현하여 위치 벡터 `X = [x, y]`를 계산합니다.

### 4. 코드 리뷰 및 고찰

#### 🟢 잘된 점 (Strengths)

1.  **통신 프로토콜의 깊이 있는 구현**: 단순 거리 측정에 그치지 않고, UWB 통신의 핵심인 클럭 동기화 오차 문제를 해결하기 위해 DS-TWR 방식을 직접 구현하였습니다.
2.  **수학적 알고리즘의 코드 전환 능력**: 최소제곱법 기반의 삼변측량이라는 수학적 이론을 C++ 코드로 성공적으로 구현하여, 복잡한 이론을 실제 임베디드 환경에 적용할 수 있는 능력을 보였습니다.
3.  **완결성 있는 시스템 구축**: Tag와 Anchor 양단의 펌웨어를 모두 개발하고, MCU, 통신 모듈, 디스플레이 등 여러 하드웨어 컴포넌트를 통합하여 하나의 완결된 측위 시스템을 구축한 경험은 시스템 전체를 보는 시각을 길러주었습니다.

#### 🟡 프로젝트 회고 및 개선 방향 (Retrospective & Future Improvements)

1.  **하드코딩된 설정 값**: Anchor의 좌표(`x`, `y` 배열)가 코드 내에 상수로 하드코딩되어 있습니다. 향후 EEPROM이나 별도의 설정 파일을 통해 이 값들을 동적으로 로드하도록 개선하면 시스템의 유연성을 높일 수 있습니다.
2.  **매직 넘버(Magic Number) 상수화**: `POLL (0)`, `POLL_ACK (1)` 등 메시지 유형을 나타내는 숫자 값들이 그대로 사용되고 있습니다. 코드 내에도 `// TODO replace by enum` 주석이 있는 만큼, `enum`을 사용하여 명시적인 상수로 정의하면 코드의 가독성과 유지보수성이 향상될 것입니다.
3.  **오차 처리 및 강건성(Robustness) 확보**: 현재는 통신 두절 시 시스템을 리셋하는 단순한 예외 처리를 사용하고 있습니다. `DW1000.getReceivePower()`와 같은 함수로 수신 신호 품질을 분석하여, 벽과 같은 장애물로 인한 NLOS(Non-Line-of-Sight) 환경에서의 측정값을 필터링하는 알고리즘(예: 칼만 필터)을 추가한다면 측위 정확도를 더욱 향상시킬 수 있습니다.

</details>

<br>
<br>
<br>

# 2. ⚙️ 듀얼 ESP32를 이용한 BLDC 모터 폐쇄 루프 제어

*   2개의 ESP32를 Master-Slave 구조로 구성하여 홀 센서(Hall Sensor) 피드백 기반의 BLDC 모터 속도/위치 제어 시스템을 구현한 프로젝트입니다.

---

<br>

<details>
<summary><strong>👨‍💼 비전공자를 위한 프로젝트 설명 (클릭하여 펼치기)</strong></summary>

### 1. 프로젝트 소개
*   **목표**: 드론, 로봇 등에 널리 쓰이는 BLDC 모터의 회전 속도와 각도를 정밀하게 제어하는 시스템을 개발하였습니다.
*   **의의**: 2개의 마이크로컨트롤러(MCU)가 역할을 분담하여 협력하는 시스템을 설계하며 **실시간 제어**, **센서 인터페이스**, **MCU 간 통신** 등 임베디드 SW 개발의 핵심 역량을 심화하였습니다.

### 2. 주요 기능
*   **실시간 상태 측정**: 모터에 부착된 3개의 홀 센서 신호를 실시간으로 읽어 현재의 회전 각도와 속도를 정확하게 계산합니다.
*   **자동 속도 제어 (폐쇄 루프 제어)**: 사용자가 목표 속도를 입력하면, 'Master' MCU가 현재 속도와 목표 속도의 차이를 계산하여 'Slave' MCU에게 모터 출력을 조절하라는 명령을 내립니다. 이 과정을 반복하여 목표 속도를 자동으로 유지합니다.
*   **역할 분담 통신**: 'Master'는 계산과 판단을 담당하는 두뇌 역할을, 'Slave'는 실제 모터를 구동하는 근육 역할을 수행하며 UART 통신으로 유기적으로 협력합니다.

### 3. 프로젝트를 통해 얻은 역량
*   **실시간 제어 시스템 설계**: 센서 피드백을 받아 실시간으로 출력을 조절하는 폐쇄 루프(Closed-loop) 제어 시스템을 직접 구현하며 제어 공학의 기본 원리를 체득하였습니다.
*   **하드웨어 인터럽트 활용**: 정밀한 측정이 필수적인 홀 센서 신호 처리를 위해 하드웨어 인터럽트를 활용하여, 놓치는 신호 없이 안정적으로 모터의 상태를 파악하는 능력을 갖추었습니다.
*   **펌웨어 멀티태스킹**: 제어 로직, 시리얼 통신 등 여러 작업을 동시에 처리하기 위해 FreeRTOS를 사용하여 태스크를 분리하고 관리하는 경험을 쌓았습니다.

</details>

<br>

<details>
<summary><strong>👩‍💻 전공자를 위한 프로젝트 설명 (클릭하여 펼치기)</strong></summary>

### 1. 프로젝트 개요
Master-Slave 구조의 듀얼 ESP32 시스템으로, 홀 센서 피드백 기반의 BLDC 모터 폐쇄 루프 속도 제어기를 구현하였습니다. Master ESP32는 제어기(Controller) 역할을, Slave ESP32는 구동기(Actuator) 역할을 수행하며 UART와 외부 인터럽트를 통해 통신합니다.

### 2. 사용 기술
*   **MCU**: `ESP32` (x2)
*   **Sensor**: `Hall Effect Sensor`
*   **Motor**: `BLDC Motor`
*   **Language/Framework**: `C++`, `Arduino Framework`, `FreeRTOS`
*   **Communication**: `UART`, `External Interrupt`

### 3. 시스템 아키텍처 및 처리 흐름
1.  **Master ESP32 (Controller)**
    *   **상태 측정**: `attachInterrupt`를 이용해 3개의 홀 센서 핀(`PIN_DIGITAL_HALL_A/B/C`)에 대한 `CHANGE` 이벤트를 감지합니다. 인터럽트 서비스 루틴(ISR) 내에서 홀 센서 값의 조합을 통해 회전 방향을 판단하고 회전각(`deg_CCW`)을 누적 계산합니다.
    *   **속도 계산**: `loop()` 함수에서 일정한 시간(`UNIT_LOOP_TIME_MILLIS`) 간격으로 누적된 각도의 변화량을 이용해 현재 각속도(`angular_v_CCW`)를 계산합니다.
    *   **제어 로직**: 별도의 FreeRTOS 태스크(`Task1code`)에서 사용자가 시리얼로 입력한 목표 속도(`target_angular_velocity`)와 현재 속도를 비교합니다. 단순 비례(P) 제어 로직에 따라 PWM 듀티 사이클 인덱스(`index_DUTY_CYCLE_ARRAY`)를 증가시키거나 감소시킵니다.
    *   **명령 전송**: 결정된 `index_DUTY_CYCLE_ARRAY` 값을 `Serial1` (UART)을 통해 Slave에게 전송하고, `PIN_INTERRUPT_BETWEEN_ESP32` 핀의 상태를 토글하여 Slave에게 데이터 수신을 알리는 외부 인터럽트를 발생시킵니다.

2.  **Slave ESP32 (Actuator)**
    *   **명령 수신**: Master로부터 오는 외부 인터럽트 신호를 `set_duty_cycle_by_interrupt` 함수로 받습니다. ISR 내부에서 `Serial1.read()`를 통해 Master가 보낸 `index_DUTY_CYCLE_ARRAY` 값을 수신합니다.
    *   **PWM 생성**: `loop()` 함수는 수신된 `index_DUTY_CYCLE_ARRAY` 값을 기반으로 PWM 신호를 생성합니다. `digitalWrite()`와 `delayMicroseconds()`를 조합하여 수동으로 PWM 파형을 만드는 소프트웨어 PWM 방식을 사용합니다.

### 4. 코드 리뷰 및 고찰

#### 🟢 잘된 점 (Strengths)
1.  **명확한 역할 분담 아키텍처**: 제어 연산과 모터 구동이라는 복잡한 작업을 두 개의 MCU에 분산하여 각 MCU가 자신의 작업에 집중할 수 있도록 설계한 점은 시스템의 안정성과 실시간성을 높입니다.
2.  **실시간성 확보 노력**: 홀 센서의 빠른 신호 변화를 놓치지 않기 위해 하드웨어 인터럽트를 사용하고, 제어 루프와 사용자 입력을 분리하기 위해 RTOS를 활용한 것은 실시간 임베디드 시스템에 대한 이해를 심화하였습니다.
3.  **폐쇄 루프 제어 직접 구현**: 이론으로만 배우기 쉬운 폐루프 제어 시스템을 실제 하드웨어와 펌웨어로 완성시킨 경험을 하였습니다.

#### 🟡 프로젝트 회고 및 개선 방향 (Retrospective & Future Improvements)
1.  **제어 알고리즘 고도화**: 현재 제어기는 목표 값과 현재 값의 차이에 따라 출력을 한 단계씩 올리거나 내리는 단순한 비례(P) 제어기입니다. 이 방식은 오버슈트나 정상상태 오차를 제어하기 어렵습니다. 적분(I) 및 미분(D) 항을 추가한 PID 제어기를 구현하면 훨씬 빠르고 안정적인 속도 제어가 가능합니다.
2.  **하드웨어 PWM 활용**: Slave에서 `delayMicroseconds()`를 사용하는 소프트웨어 PWM은 블로킹 방식으로 동작하여 다른 작업을 방해하고, 타이밍이 부정확할 수 있습니다. ESP32에 내장된 고성능 `MCPWM` (Motor Control PWM) 주변장치를 사용하면 CPU 부하 없이 훨씬 정밀하고 안정적인 다상 PWM 신호를 생성할 수 있습니다.
3.  **통신 프로토콜 강건성**: 현재 UART 통신은 단순 바이트 전송으로, 노이즈로 인한 데이터 깨짐에 대응할 수 없습니다. 시작/종료 바이트, 체크섬(Checksum) 등을 포함한 간단한 프로토콜을 정의하면 통신의 신뢰성을 크게 향상시킬 수 있습니다.
4.  **코드 가독성**: `MAX_PWM (80)`, `DELAY_BETWEEN_INTERRUPT (500)` 등 의미를 알기 어려운 매직 넘버들이 코드 전반에 사용되었습니다. `const` 또는 `constexpr`를 사용해 의미 있는 이름의 상수로 정의하면 코드의 가독성과 유지보수성이 크게 향상됩니다.

</details>

<br>
<br>
<br>

# 3. 🦾 WiFi-Mesh 네트워크 기반 다관절 로봇 팔 제어

*   `painlessMesh` 라이브러리를 활용하여 여러 개의 관절(Client)을 하나의 제어기(Server)에서 무선으로 동시에 제어하는 분산 제어 시스템을 구축한 프로젝트입니다.

---

<br>

<details>
<summary><strong>👨‍💼 비전공자를 위한 프로젝트 설명 (클릭하여 펼치기)</strong></summary>

### 1. 프로젝트 소개
*   **목표**: 여러 개의 모터로 구성된 로봇 팔을 복잡한 선 연결 없이 무선으로 제어하는 시스템을 개발하였습니다.
*   **의의**: 중앙 제어기 하나가 여러 개의 하위 장치와 통신하며 협력하는 **분산 제어 시스템**을 직접 설계하고 구현하며, **네트워크 프로그래밍**과 **시스템 통합 역량**을 길렀습니다.

### 2. 주요 기능
*   **안정적인 무선 통신망**: 일반적인 Wi-Fi 대신, 일부 장치에 문제가 생겨도 다른 장치들이 우회해서 통신할 수 있는 그물망 구조의 '와이파이 메시(WiFi-Mesh)' 기술을 적용하여 통신 안정성을 높였습니다.
*   **원격 동시 제어**: PC에 연결된 중앙 제어기(Server)에서 `j1_90` (1번 관절을 90도 움직여라) 와 같은 간단한 명령을 내리면, 해당 관절(Client)이 명령을 무선으로 받아 스테퍼 모터를 정밀하게 움직입니다.
*   **상태 피드백**: 각 관절은 명령을 수행한 후, 자신의 상태를 다시 중앙 제어기에 보고하여 명령이 제대로 수행되었는지 확인할 수 있는 기반을 마련하였습니다.

### 3. 프로젝트를 통해 얻은 역량
*   **네트워크 프로그래밍**: ESP32의 Wi-Fi 기능을 활용하여 다수의 기기가 서로 통신하는 메시 네트워크를 구축하고, 데이터를 주고받는 프로그램을 작성하는 능력을 갖추었습니다.
*   **데이터 처리 능력**: 장치 간에 명령과 상태를 주고받기 위해 표준 데이터 형식인 JSON을 사용하여, 구조화된 데이터를 생성하고 해석하는 능력을 길렀습니다.
*   **분산 시스템 설계**: 하나의 중앙 제어기와 여러 개의 독립적인 실행 유닛으로 구성된 분산 시스템을 직접 설계하고 구현한 경험을 통해 시스템 아키텍처에 대한 이해를 높였습니다.

</details>

<br>

<details>
<summary><strong>👩‍💻 전공자를 위한 프로젝트 설명 (클릭하여 펼치기)</strong></summary>

### 1. 프로젝트 개요
`painlessMesh` 라이브러리를 이용한 1:N 무선 로봇 팔 제어 시스템입니다. Server 노드는 PC로부터 시리얼 명령을 받아 제어 명령(JSON)을 생성하고, 이를 Mesh 네트워크에 브로드캐스트합니다. 각 Client 노드(관절)는 메시지를 수신하여 자신의 ID와 일치하는 명령일 경우 스테퍼 모터를 구동하여 해당 관절을 움직입니다.

### 2. 사용 기술
*   **MCU**: `ESP32`
*   **Actuator**: `Stepper Motor`
*   **Language/Framework**: `C++`, `Arduino Framework`
*   **Libraries**: `painlessMesh`, `ArduinoJson`, `Stepper`

### 3. 시스템 아키텍처 및 처리 흐름
1.  **Server Node**
    *   `painlessMesh` 라이브러리를 사용해 메시 네트워크를 초기화하고 마스터 역할을 수행합니다.
    *   `loop()` 함수에서 `Serial.available()`을 통해 PC로부터 `j<ID>_<degree>` 형식의 명령을 수신합니다. (예: `j1_90`)
    *   명령을 파싱하여 `ArduinoJson` 라이브러리로 `{"id":<ID>, "degreeCommanded":<degree>, ...}` 형태의 JSON 메시지를 생성합니다.
    *   `mesh.sendBroadcast()` 함수를 호출하여 생성된 JSON 메시지를 네트워크에 연결된 모든 클라이언트 노드에 전파합니다.

2.  **Client Node (Joint)**
    *   `DeviceID`를 통해 각 관절의 고유 ID를 부여받습니다.
    *   `painlessMesh` 네트워크에 참여하고, `receivedCallback` 함수를 등록하여 메시지 수신을 대기합니다.
    *   메시지 수신 시, `ArduinoJson`으로 파싱하여 `id` 필드가 자신의 `DeviceID`와 일치하는지 확인합니다.
    *   명령이 자신을 향한 것이 맞으면, `Stepper` 라이브러리의 `myStepper.step()` 함수를 호출하여 `degreeCommanded` 값에 따라 스테퍼 모터를 구동합니다.
    *   명령을 수행한 후, 자신의 현재 상태를 담은 JSON 메시지를 다시 `sendBroadcast`하여 서버 및 다른 노드에 알립니다.

### 4. 코드 리뷰 및 고찰

#### 🟢 잘된 점 (Strengths)
1.  **확장성 있는 네트워크 아키텍처**: `painlessMesh`를 활용하여 중앙 서버와 다수의 클라이언트로 구성된 확장 가능한 무선 분산 제어 시스템을 성공적으로 구축하였습니다.
2.  **표준 데이터 포맷 사용**: 장치 간 통신에 JSON이라는 표준화된 데이터 교환 형식을 사용하여 메시지의 명확성과 확장성을 확보하였습니다.
3.  **모듈화된 설계**: 로봇 팔의 각 관절을 독립적인 Client 노드로 모듈화하여, 관절의 추가 및 제거가 전체 시스템에 미치는 영향을 최소화하였습니다.

#### 🟡 프로젝트 회고 및 개선 방향 (Retrospective & Future Improvements)
1.  **통신 효율성**: 현재 모든 명령과 상태를 `sendBroadcast`를 통해 전송하고 있습니다. 이는 노드 수가 증가할수록 불필요한 네트워크 트래픽을 유발합니다. 서버가 특정 클라이언트에게 명령을 보낼 때는 `mesh.sendSingle(nodeId, msg)`을 사용하는 것이 더 효율적입니다.
2.  **불완전한 피드백 루프**: Client는 명령 수행 후 상태를 브로드캐스트하지만, Server의 `receivedCallback` 함수는 비어 있어 이 피드백을 수신하여 처리하는 로직이 구현되어 있지 않습니다. 명령 수행 성공/실패 여부 확인, 에러 복구 등 견고한 시스템을 위해 피드백 루프를 완성해야 합니다.
3.  **명령 파서의 안정성**: Server의 시리얼 명령 파싱 로직이 `Serial.read()`를 문자 단위로 여러 번 호출하는 방식으로 구현되어 있어, 입력 속도나 타이밍에 따라 오작동할 수 있습니다. `readStringUntil()`과 같은 함수를 사용해 라인 단위로 읽고 파싱하는 것이 더 안정적입니다.
4.  **매직 넘버 상수화**: Client 코드에서 `stateJoint.degreeCommanded * 100/45`와 같이 기구부의 특성과 관련된 매직 넘버가 사용되었습니다. 이는 스텝각, 기어비 등과 관련된 값으로 추정되며, `GEAR_RATIO` 등 의미 있는 이름의 상수로 정의하여 코드의 의도를 명확히 해야 합니다.

</details>
